import pytest

from deepteam.vulnerabilities import ExploitToolAgent
from deepteam.vulnerabilities.exploit_tool_agent import ExploitToolAgentType
from deepteam.test_case import RTTestCase


class TestExploitToolAgent:

    def test_exploit_tool_agent_all_types(self):
        types = ["privilege_escalation", "financial_manipulation", "data_destruction"]
        exploit_tool_agent = ExploitToolAgent(types=types)
        assert sorted(type.value for type in exploit_tool_agent.types) == sorted(types)

    def test_exploit_tool_agent_all_types_default(self):
        exploit_tool_agent = ExploitToolAgent()
        assert sorted(type.value for type in exploit_tool_agent.types) == sorted(
            type.value for type in ExploitToolAgentType
        )

    def test_exploit_tool_agent_privilege_escalation(self):
        types = ["privilege_escalation"]
        exploit_tool_agent = ExploitToolAgent(types=types)
        assert sorted(type.value for type in exploit_tool_agent.types) == sorted(types)

    def test_exploit_tool_agent_financial_manipulation(self):
        types = ["financial_manipulation"]
        exploit_tool_agent = ExploitToolAgent(types=types)
        assert sorted(type.value for type in exploit_tool_agent.types) == sorted(types)

    def test_exploit_tool_agent_data_destruction(self):
        types = ["data_destruction"]
        exploit_tool_agent = ExploitToolAgent(types=types)
        assert sorted(type.value for type in exploit_tool_agent.types) == sorted(types)

    def test_exploit_tool_agent_all_types_invalid(self):
        types = ["privilege_escalation", "financial_manipulation", "data_destruction", "invalid"]
        with pytest.raises(ValueError):
            ExploitToolAgent(types=types)

    def test_simulate_attacks_returns_expected_cases(self):
        exploit_tool_agent = ExploitToolAgent(types=["privilege_escalation"])
        test_cases = exploit_tool_agent.simulate_attacks(attacks_per_vulnerability_type=2)

        assert len(test_cases) == 2
        assert all(isinstance(tc, RTTestCase) for tc in test_cases)
        assert all(tc.vulnerability == "Exploit Tool Agent" for tc in test_cases)
        assert all(
            tc.vulnerability_type == ExploitToolAgentType.PRIVILEGE_ESCALATION for tc in test_cases
        )

    def test_assess_returns_results(self):
        exploit_tool_agent = ExploitToolAgent(types=["data_destruction"], async_mode=False)

        def dummy_model_callback(prompt):
            # Provide a simple pass-through or minimal callback if required by your real env
            return prompt

        results = exploit_tool_agent.assess(
            model_callback=dummy_model_callback,
        )

        assert exploit_tool_agent.is_vulnerable() is not None
        assert exploit_tool_agent.simulated_attacks is not None and isinstance(
            exploit_tool_agent.simulated_attacks, dict
        )
        assert exploit_tool_agent.res is not None and isinstance(exploit_tool_agent.res, dict)
        assert ExploitToolAgentType.DATA_DESTRUCTION in results
        assert len(results[ExploitToolAgentType.DATA_DESTRUCTION]) == 1
        test_case = results[ExploitToolAgentType.DATA_DESTRUCTION][0]
        # The score and reason will depend on the real metric evaluation
        assert hasattr(test_case, "score")
        assert hasattr(test_case, "reason")

    def test_get_metric_returns_cross_context_retrieval_metric(self):
        from deepteam.metrics import ExploitToolAgentMetric

        exploit_tool_agent = ExploitToolAgent(
            async_mode=True, verbose_mode=True, evaluation_model="gpt-4o"
        )
        metric = exploit_tool_agent._get_metric(ExploitToolAgentType.FINANCIAL_MANIPULATION)
        assert isinstance(metric, ExploitToolAgentMetric)
        assert metric.async_mode is True
        assert metric.verbose_mode is True

    @pytest.mark.asyncio
    async def test_a_assess_returns_async_results(self):
        exploit_tool_agent = ExploitToolAgent(types=["financial_manipulation"], async_mode=True)

        async def dummy_model_callback(prompt):
            return prompt

        results = await exploit_tool_agent.a_assess(
            model_callback=dummy_model_callback,
        )

        assert exploit_tool_agent.is_vulnerable() is not None
        assert exploit_tool_agent.simulated_attacks is not None and isinstance(
            exploit_tool_agent.simulated_attacks, dict
        )
        assert exploit_tool_agent.res is not None and isinstance(exploit_tool_agent.res, dict)
        assert ExploitToolAgentType.FINANCIAL_MANIPULATION in results
        assert len(results[ExploitToolAgentType.FINANCIAL_MANIPULATION]) == 1
        test_case = results[ExploitToolAgentType.FINANCIAL_MANIPULATION][0]
        assert hasattr(test_case, "score")
        assert hasattr(test_case, "reason")
